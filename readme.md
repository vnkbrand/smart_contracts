<!-- Smart Contract Basics -->

<!-- Week 1 -->

1. Why Smart Contracts?

Bitcoin added an embedded script - conditional feature that was bootstrapped as a softfork in Bitcoin.  It enabled simple conditional transfers.

A significant contribution of Ethereum is a working smart contract layer that supports any arbitrary code execution over the blockchain.

Smart contract allows for user-defined operations of arbitrary complexity.

This feature enhances the capability of Ethereum blockchain to be a powerful decentralized computing system.

Examples:
- Transfer on specific date.
- Credentials need to be provided.
- Need to deliver specific product for payment.

This introduces conditions, rules, policies beyond that of which a simple money transfer cryptocurrency protocols can handle.

2. Smart Contract Advantages
- Transfers assets other than value or crypto.
- Smart contract allows specification of rules for an operation on the blockchain.
- It facilitates implementation of policies for transfer of assets in a decentralized network. 
- It also adds programmability and intelligence to the blockchain.

A smart contract embeds function that can be invoked by messages that are like function calls.
These messages and the input parameters for a single message are specified in a transaction.

All the operations are transparent and are recorded on the blockchain.
Customers can directly access the tools without an intermediary like a bank.

3. Smart Contracts
Smart contract work with the application-specific semantics and constraints of the transaction and verify, validates, and executes them.

Once the code is deployed, it cannot be changed.

We will have to redeploy the code as a new smart contract, or somehow redirect the calls from a old contract to the new one.

Smart contract can store variables in it called state variables. We could retrieve how these variables change over the blocks.

VARIABLES:
1. pragma directive
2. name of the contract
3. data or the state variable that define the state of the contract
4. collection of function to carry out the intent of a smart contract

4. 3 Steps in the development of a smart contract
- Design
Greeter has a string variable named yourName, the constructor Greeter, a set function to set the name, and a hello function that returns a string name so that you can use it to greet the world.

- Code
Version of solidity. Name on contract. State variable. Functions. 

- Test
Remix is where we test. 

4. Smart Contracts - Compiling on Remix

ARTIFACTS AFTER COMPILATION:

ABI, Application Binary Interface - the interface schema for a transaction to invoke functions on the smart contract instance bytecode.

Contract bytecode - this is the bytecode that is executed for instantiating a smart contract on the EVM. Think of it like executing a constructor of a smart contract to create an object.

WebDeploy script -  json script to web application to invoke smart contract function AND script for programmatically deploying a smart contract from a web application.

Gas estimates - this provides a gas estimates for deploying the smart contract and for the function invocation.

Function hashes - first four byte of the function signatures to facilitate function invocation by a transaction.

Instance bytecode - the bytecode of the smart contract instance.

5. Deploying Smart Contracts

i. First, a smart contract solution is written in high-level language and compiled bytecode.

ii. An ABI is also generated for high-level language application. Example, Web Apps to interact with the binary smart contract. 

iii. The smart contract requires an address for itself so that transaction can target it for invocation of its function. The contract address is generated by hashing the sender's account address and its nonce. 

DEPLOYING A SMART CONTRACT USING THE REMIX IDE

1. Enter the smart contract code inn the IDE and Compile
2. Remix generates several artifacts
3. Remix provides us with the Web3 deployment script which contains a bytecode. Application Binary Interface, ABI, and account detail.
4. Deploy - execute script
5. Once the deployment is done, the address is generated by hashing creator's account number and nonce.
6. To interact with the smart contract, we'll use the smart contract address, ABI definition, and the function hashes.

<!-- WEEK 2 - SOLIDITY -->
Solidiy - It is specially designed to write smart contracts and to target the Ethereum Virtual Machine.

Smart contracts are like classes in OOP

SMART CONTRACT STRUCTURE

1. Data or state variables

2. Functions - Constructor (default or specified - ONLY ONE), Fallback function, View functions, Pure functions, Public functions, Private, Internal, External

3. User defined types in struct and enums

4. Events

FUNCTION DEFINITIONS

1. Function header, followed by the function code in {}

Function header can be as simple as an anonymous noname function to a complex function header loaded with a lot of details.
- function is key word
- parameters - any number of pairs type identifier

Function code contains the local data and statements to process the data and return the results of processing.

Any number of values can be returned, unlike common programming languages that allow only one return value. For example, multiple variables, age and gender, can be assigned return values from a function getAgeGender.

In summary, a smart contract for Ethereum can be specified using Solidity defined structure and functions. A variety of function types are provided for expressing smart contract operations. A smart contract in Solidity can inherit its attribute and functionality from another smart contract.